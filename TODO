mediarover TODO
===============
- update/rewrite all unittests to reflect recent changes
   - write test for mediarover.util.filesystem to verify that it is correctly
	caching episodes when they are retrieved
x add filtering ability, ie. don't want to download nzb's that are labelled
as password protected => "Lost (2004) - 5x05 - blah (password protected)"
- handle tv directory with no season folders, ie all episodes are in one 
folder.
- allow user to specify whether or not they want pre-season recap episodes 
(ie. 3x00)
- look at handling mini or fractional episodes 
(ie. Big Brother (IT) - 9x45a - Daily Show).
	- update regex to look for optional letter following episode number
	- store it in episode object and spit it out whenever converting episode
	to string
- update custom errors to allow setting an error number.  That way I can 
handle different numbered error specifically
	- update util.filesystem to number different errors
x when looking for episode on disk, search all subdirectories for possible 
files
	x use os.walk instead of os.listdir
x look at moving daily flag to series object as it is a property of the show
- standardize category types that are supported by application
	- each source should return one of supported categories when queried
- update mediarover.error so that it doesn't accept arguments to apply to the error message
  - update to accept a logging level
x add all watched series to dict
x register as a dependency
- all code that creates episodes uses dict of series objects to find series
x update series interface to include methods that
  a) say whether episode exists on disk or not, and
  b) say whether given episode is of better quality than existing episode on disk
x update series so that it can exist across multiple tv_roots
x create a FilesystemSeries that subclasses Series.  This object will contain all filesystem related method and checks
  x will also contain list of episodes for that series

x for each source subclass, create an abstract factory.  All implementing subclasses will need to be able to handle daily, regular, and 
multi-part episodes.
  x have one handle method, and one new_from_string method which returns the appropriate object

x update source.py to be an interface rather than an implementation
	x look at creating a RssSource object

- stop logging from within error objects.  Add logging call before each raise error.  Fatal errors will print stack trace

- update config template/spec
	x update multiepisode options in config template/spec
	x remove aggressive flag
	x remove UI options
	x rename multiepisode to multipart
	x update comments in config.template

- come up with some way to prune stale data from in_progress table
x remove quality property from queue.job or determine quality in source and pass as param when creating new job
- to address the possibility of nzb's having the same title, look at using the url or other piece of data to make title unique

x rename series_episode template to single_episode template
x add format parameter for episode quality

- think about duplicate episodes on disk (no timestamp) and how MR handles them when reading in a series episodes
- update config version number
- problem: adding something to queue, get ok back from sabnzbd
  - sab isn't able to retrieve url and add to queue
  - mr registers download with in_progress table
  - next time mr is run, it attempts to schedule downloads again and we get a not unique error because download title is already in table
  - maybe it should silently fail?
